``` ts
/**
 * 主要适用以下场景
 * 
 * 给你一个数组 window，已知其最值为 A，如果给 window 中添加一个数 B，那么比较一下 A 和 B 就可以立即算出新的最值；但如果要从 window 数组中减少一个数，就不能直接得到最值了，因为如果减少的这个数恰好是 A，就需要遍历 window 中的所有元素重新寻找新的最值。
 * 
 * 如果单纯地维护最值的话，优先级队列很专业，队头元素就是最值。但优先级队列无法满足标准队列结构「先进先出」的时间顺序，因为优先级队列底层利用二叉堆对元素进行动态排序，元素的出队顺序是元素的大小顺序，和入队的先后顺序完全没有关系。
 * 
 * 所以，现在需要一种新的队列结构，既能够维护队列元素「先进先出」的时间顺序，又能够正确维护队列中所有元素的最值，这就是「单调队列」结构。
 */

// 单调队列主要还是和滑动窗口问题结合，求滑动窗口中的最值很好用！

// 通用实现

type Comparator<T> = (a: T, b: T) => number;

class MonotonicQueue<T> {
  // 常规队列，存储所有元素
  private q: T[] = [];
  // 元素降序排列的单调队列，头部是最大值
  private maxq: T[] = [];
  // 元素升序排列的单调队列，头部是最小值
  private minq: T[] = [];
  private compare: Comparator<T>;

  constructor(compareFn?: Comparator<T>) {
    // 默认比较函数（只适用于 number）
    this.compare = compareFn ?? ((a: any, b: any) => a - b);
  }

  push(elem: T): void {
    // 维护常规队列，直接在队尾插入元素
    this.q.push(elem);

    // 维护 maxq，将小于 elem 的元素全部删除
    while (
      this.maxq.length > 0 &&
      this.compare(this.maxq[this.maxq.length - 1], elem) < 0
    ) {
      this.maxq.pop();
    }
    this.maxq.push(elem);

    // 维护 minq，将大于 elem 的元素全部删除
    while (
      this.minq.length > 0 &&
      this.compare(this.minq[this.minq.length - 1], elem) > 0
    ) {
      this.minq.pop();
    }
    this.minq.push(elem);
  }

  // maxq 的头部是最大元素
  max(): T | undefined {
    return this.maxq[0];
  }

  // minq 的头部是最小元素
  min(): T | undefined {
    return this.minq[0];
  }

  pop(): T | undefined {
    // 从标准队列头部弹出需要删除的元素
    const deleteVal = this.q.shift();
    if (deleteVal === undefined) return undefined;

    // 由于 push 的时候会删除元素，deleteVal 可能已经被删掉了
    if (deleteVal === this.maxq[0]) {
      this.maxq.shift();
    }
    if (deleteVal === this.minq[0]) {
      this.minq.shift();
    }

    return deleteVal;
  }

  size(): number {
    // 标准队列的大小即是当前队列的大小
    return this.q.length;
  }

  isEmpty(): boolean {
    return this.q.length === 0;
  }
}

```